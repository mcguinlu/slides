---
title: "Introduction to Shiny"
subtitle: ""
author: "Luke McGuinness"
institute: "Dept of Population Health Sciences, <br> Bristol Medical School"
date: "01/09/2019 <br> <br> Twitter/Github: mcguinlu"
output:
  xaringan::moon_reader:
    css: [default, hygge, custom.css]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightSpans: true
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: |
        <div class="progress-bar-container">
          <div class="progress-bar" style="width: calc(%current% / %total% * 100%);">
          </div>
        </div>
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
library(countdown)
library(shiny)
library(kableExtra)
library(BristolVis)
```

# Overview of this session

- Background to .cb[`shiny`]

--

- Creating your own app

  - Set-up

  - User interface & Control widgets

  - Outputs

--

- Getting more from .cb[`shiny`]

  - Execution
    
  - Customising your app
  
  - Reactive programming
  
  - Publishing your app

--

- Tips and tricks

---

# Public service announcements

.Large[
__Workshop plan (note: practical exercises are mixed in)__


* 0 => 1 : First part of workshop
* 1 => 1.5 Coffee
* 1.5 => 3 : Second part of workshop

]
<br>

--

.Large[
__Please ask questions as we go along!__
]
<br>

--

.Large[
__We will be using timers as part of this course:__
]

`r countdown(minutes =0, seconds=15, warn_when = 10, play_sound=TRUE, right = "34%" )`

---

# Public service announcements
.Large[
__I pronounce the letter R oddly:__
]

.center[

.col-left[
<img src="figs/oar.png" width =150 height =150>  
R  
("oar")
]

.col-right[
<img src="figs/pirate.jpg" width =150 height =150>   
R  
("arr")
]
<br>
<br>
<br>
.col-center[.Large[.bold[means]]]
]
<br>
<br>
<br>
<br>
<br>
<br>

--

.center[
<img src="figs/r-joke.png" width="480" height="175" class="border">
]

---

class: inverse, middle, center

# Introduction: <br> Background to `shiny`

---
## What is .cb[`shiny`]?

.cb[`shiny`] is an R package build interactive web applications ("apps") straight from R.

<br>

.center[
<img src="figs/shiny.png" width = 350 height=400>
]

---

## Why is it called .cb[`shiny`]?

.pull-left[
**Likely (but less interesing) reason**

Allows you “*to build beautiful, responsive, and powerful applications with minimal effort.*”]

--

.pull-right[
**Unlikely (but more interesing) reason**

Speculation that it comes from the show *Firefly*, in which “shiny” means “good” or “valuable”.]

<br>

.center[

<img src="https://media1.giphy.com/media/eSjmuv0wMC9r2/source.gif" width="500" height="300">

]

---

## Benefits of .cb[`shiny`] for visualisation


<iframe src="https://mcguinlu.shinyapps.io/shiny-teaching-apps/" class="foo" width="1400"  height="475" scrolling="no" frameBorder="0"></iframe>

.small[
_Data shown is from the `med` dataset used throughout this course_
]

---

class: inverse, middle, center

# Introduction: <br> Structure of a `shiny` app

---

## Structure of a .cb[`shiny`] app

A .cb[`shiny`] app has three components:

* .large[.bold[User interface]]

  * Defines the layout of your app
  * Controls what it looks like (themes/fonts/etc)
  
--

* .large[.bold[Server]]

  * Defines the logic needed to build the app
  * Performs computational work 
  
--

* .large[.bold[Call to the .cb[`shinyApp`] function]]

  * Creates the app from an user interface and server pair


---

class: inverse, center, middle

# Creating your own app: <br> Getting started

---

exclude: false

## Setting up a .cb[`shiny`] app

.Large[
This _ui/server_ structure can be implemented in two ways:
]

--

.pull-left[
.Large[
.center[
.bold[
Option 1
]
A single file called app.R]]]
--

.pull-right[
.Large[
.center[
.bold[
Option 2
]
Two files: ui.R and server.R]]]

--
.Large[.center[.pull-left[.red[.bolder[
<span style='font-size:100px;'>&#8593;</span>  

This is the structure  
we will use.
]
]
]
]
]

---

exclude: false

## Option 1: single file (*app.R*)

.Large[
__User interface container__
]

``` {r, eval = FALSE}
# USER INTERFACE
ui <- fluidPage(  #<<
      . . .
)  #<<


# SERVER
|
| 
|

# RUN THE APP
|      
```


---

exclude: false

## Option 1: single file (*app.R*)


.Large[
__Server function__
]

``` {r, eval = FALSE}
# USER INTERFACE
ui <- fluidPage( 
      . . .
) 


# SERVER
server <- function(input, output) { #<<
      . . .
} #<<

# RUN THE APP
|

```

---

## Option 1: single file (*app.R*)


.Large[
__Call to the .cb[`shinyApp`] function__
]

``` {r, eval = FALSE}
# USER INTERFACE
ui <- fluidPage(
      . . .
)


# SERVER
server <- function(input, output) { 
      . . .
} 

# RUN THE APP
shinyApp(ui = ui, server = server) #<<
 
```

---

## Option 2: two-file approach
__Create new folder named "app_directory" with two files:__

``` {r, eval = FALSE}
~/app_directory
|-- ui.R
|-- server.R
```

<hr>

__The files will contain the relevant functions:__
.pull-left[
``` {r, eval = FALSE}
ui<-fluidPage( 
      . . .
) 
```
.center[*ui.R*]]

.pull-right[
``` {r, eval = FALSE}
server<-function(input,output){
      . . .
}
```
.center[*server.R*]]

<hr>

__Then run the app using:__

``` {r, eval = FALSE}
runApp("app_directory")
```


???

Single file apps have the advantage of being able to run from the console -> easy to share.

If using multi-file apps, you can open the ui/server seperately and have them open simultaneously in the editor -> makes it easy to match inputs and outputs

---

## Running your app

.large[.bold[There are two options when running your app:]]


Open the app by running .cb[`runApp("app-dir")`] in the console, where "app-dir" is the name of the directory containing your app.R script: 

```{r, eval=FALSE}
runApp("luke")
```

.center[
.bold[
.large[
OR
]
]
]

Open the app.R script in Rstudio and then:

* click the "Run App" button:

.center[<img src="figs/run-app-button.png">]

* Use the keyboard short-cut: _Ctrl/Command+Shift+Enter_


---

## .yt[Your Turn: Run your first app]
.Large[

* Install .cb[`shiny`] if you haven't done so already:
]

```{r,eval=FALSE}
install.packages("shiny")
library(shiny)
```

.Large[
* Open "Example1.R" from the USB drive

* Run it both:

  * from the console, and
  * using the "Run App" button

]

`r countdown(minutes = 5, play_sound=TRUE, warn_when = 30)` 

---

class: inverse, center, middle

# Creating your own app: <br> User interface

---

## Shiny: inputs and outputs


The user interface is essentially a place to put stuff. . . 



Shiny is basically a series of inputs and outputs

* Inputs:  information from user interface => server

* Outputs: information from server => user interface

---

## .cb[`sidebarLayout()`]

Common layout for .cb[`shiny`] apps

.center[

<img src="figs/sidebarlayout.png" height = 450>

]


---

## .cb[`sidebarLayout()`]

Defined in code as:

``` {r, eval = FALSE}
sidebarLayout(
  sidebarPanel(
    # Control widgets
  ),
  mainPanel(
    # Outputs
  )
)
```


Conventions for use:
* The .cb[`sidebarPanel`] is usually used to house the control widgets that capture user input.

* The .cb[`mainPanel`] is usually used to present the output of the app (text/graph/results).

---

class: inverse, center, middle

# Creating your own app: <br> Control widgets

---

## A widget for every occasion

Control widgets are used to capture user input and vary based on type of input:

.center[
<img src="figs/widgets.png" height = 400>


Image sourced from the .cb[`shiny`] Rstudio [cheatsheet](https://shiny.rstudio.com/images/shiny-cheatsheet.pdf)
]

---

## The anatomy of a widget

All control widgets have two elements in common:

* __inputId__: Unique ID for that widget

* __label__: Text to be displayed beside the widget (which can be left blank)

```{r, eval =FALSE}
textInput(inputId = "textboxinput",
          label = "") 
```

.center[
<img src="figs/inputText.png", width = 300>
]

Other elements are specific to the widget you are using:

```{r, eval=FALSE}
selectInput(inputId = "fillby",
            label = "Variable to fill by",
            choices = c("Health","treament")),

```

.center[
<img src="figs/drop-down.png" width = 300>
]

---

## A note on commas in the user interface

Clarify when and where they are needed

---

## .yt[Your Turn: Design a user interface]
.large[
* Open "Example2.R"

* Identify the elements of .cb[`sidebarLayout`]

* Run the app

* Make the following changes:
  * Change the title of the app to "YYYY"
  * Add a new selectInput widget to the sidebar, with the options "sex" and "diet"
  * Add a new textboxInput widget to the sidebar with the label "Plot title"
  
* What is the value of .cb[`input$textbox`] when the following is entered in it?  
_This is a test_    

]

`r countdown(minutes = 5, play_sound=TRUE, warn_when = 30)`

???

Last question is important demonstration of how text is saved to input$<id>


---


class: inverse, center, middle

# Creating your own app: <br> Reactive outputs

---

## Creating outputs - the basics

.small[
``` {r, eval = FALSE}
# Define UI
ui <- fluidPage(
  textOutput("textout")
)

# Define server
server <- function(input, output) {

    output$textout <- renderText({ #<<
        "This is the best app ever!" #<<
    }) #<<
}

# Run the application 
shinyApp(ui = ui, server = server)

```
]

Two steps:

* Add the code to render the R object to the server function using a .cb[`render*()`] function

---

## Creating outputs - the basics

.small[
``` {r, eval = FALSE}
# Define UI 
ui <- fluidPage(
  textOutput("textout") #<<
)

# Define server
server <- function(input, output) {

    output$textout <- renderText({
        "This is the best app ever!"
    })
}

# Run the application 
shinyApp(ui = ui, server = server)

```
]

Two steps:

* Add the code to render the R object to the server function using a .cb[`render*()`] function

* Add the resulting R object to the user interface using the corresponding .cb[`*Output()`] function.
---

## Rendering the output

Similar to inputs, there are different .cb[`render\*()`]/.cb[`*Output()`] function pairs for different types of output:


.center[
<img src="figs/render.png" width = 650 class="border">

Image sourced from the .cb[`shiny`] Rstudio [cheatsheet](https://shiny.rstudio.com/images/shiny-cheatsheet.pdf)

]

---

## Static vs reactive outputs

.Large[

So far, the outputs we have created are not reactive.

Reactive outputs are those that make use of the value of a control widget

]

---

## Accessing widget values

The inputId of the widget is important

Remember the server function:

```{r, eval = FALSE}
server <- function(`input`, output) {
  . . . 
}

```

--
<hr>

For the following widget:

```{r, eval = FALSE}
textInput(inputId = `"textboxinput"`,
          label = "")
```

its value is defined by 

```{r eval= FALSE}
input$`textboxinput`
```

???

shiny stores all userdefined information in a list-like object called "input"

---

## Using the value of the control widgets
.small[
**renderPlot() function in the server**
```{r eval=FALSE}
output$barPlot <- renderPlot({
       ggplot(data = med, aes_string(fill = `input$fill`)) +
          geom_histogram(aes(x = status), stat = "count") +
          labs(fill = "Fill")
       })
```
]

<hr>

--

.small[
**Changes based on value selected by user in UI**

When *input$histogram_fill = health*:

```{r eval=FALSE}
ggplot(data = med, aes_string(fill = `"health"`)) +
   geom_histogram(aes(x = status), stat = "count") +
   labs(fill = "Fill")
```
]

--

.small[
<br>
When *input$fill = treatment*:

```{r eval=FALSE}
ggplot(data = med, aes_string(fill = `"treatment"`)) +
   geom_histogram(aes(x = status), stat = "count") +
   labs(fill = "Fill")
```
]

---

## . . . and .cb[`switch`]!

.large[
In the previous example, we used the aes_string() function to get around the fact that the value of .cb[`input$fill`] was in quotes

The .cb[`switch`] function converts the value of .cb[`input$<id>`] from a .cb[`selectInput()`] box into anything you like. 
]

```{r, eval=FALSE}

server <- function(input, output) {
  
 output$barPlot <- renderPlot({
    
    fill <- switch(input$fill, #<<
                     "treatment" = med$treatment, #<<
                     "health" = med$health) #<<
    
    ggplot(data = med, `aes`(fill = `fill`)) +
      geom_histogram(aes(x = status), stat = "count") 
    
  })
}

```

---

## A comment on brackets

.Large[

Note the difference between:

```{r, eval=FALSE}
renderPlot(`{}`) 
renderPlot()
```

Whenever you have a function argument that's more than just a single expression, you need to use curly braces

Good practice to use .cb[{}] all the time, so that you don't get parsing errors
]


---

## .yt[Your Turn: Create reactive content]

Introduction to the data

```{r, eval = FALSE}
install.packages("devtools")
devtools::install_github("statcourses/BristolVis")
library(BristolVis)
```

The dataset we encourage you to use is the .cb[`birthweight`] dataset:

```{r, echo=FALSE, width = 800}
kable(head(bmi[3:10,]),row.names = FALSE)
```

---

## .yt[Your Turn: Create reactive content]

* Open "Example3.R"

* Run the code and the app to familarise yourself with it

  
* Examine the DT:renderDataTable code in the UI/server
  * Why is the table not being displayed in the app?
  * Fix the code in the UI so that the table is displayed in the .cb[`mainPanel`]

* Examine the renderPlot code in the UI/server
  * Update the code so that the fill colour is set by the value of .cb[`input$fill`]
  * Update the code so that the title of the plot is defined by the value of the input from the .cb[`inputTextbox`] widget

* Re-run the app to ensure that the changes have worked


`r countdown(minutes = 10, play_sound=TRUE, warn_when = 30)`


---

class: inverse, center, middle

# Getting more from `shiny`: <br> Execution

---

## Where you put your code is important


In "Example3.R", we loaded the .cb[`BristolVis`] and .cb[`ggplot2`] packages using:

```{r,eval=FALSE}
library(ggplot2)
library(BristolVis)
```

Important that this is put outside both the user interface container and the server

---

# How your app is executed

Only ever once, when the app is launched

``` {r, eval = FALSE}
library(shiny) #<<
library(BristolVis) #<<
library(ggplot2) #<<

ui <- fluidPage(
      selectInput(inputId = "fill",
                         label = "Variable to fill by:",
                         choices = c("health","treatment")),
      plotOutput("barPlot")
)

server <- function(input, output) {
   output$barPlot <- renderPlot({
      ggplot(data = med, aes_string(fill = input$fill)) +
         geom_histogram(aes(x = status), stat = "count")
      })
}

shinyApp(ui = ui, server = server) #<<

```

---

# How your app is executed

Once each time a new user visits

``` {r, eval = FALSE}
library(shiny)
library(BristolVis)
library(ggplot2)

ui <- fluidPage(
      selectInput(inputId = "fill",
                         label = "Variable to fill by:",
                         choices = c("health","treatment")),
      plotOutput("barPlot")
)

server <- function(input, output) { #<<
   output$barPlot <- renderPlot({ #<<
      ggplot(data = med, aes_string(fill = input$fill)) + #<<
         geom_histogram(aes(x = status), stat = "count") #<<
      }) #<<
} #<<

shinyApp(ui = ui, server = server)

```

---

# How your app is executed

Each time the value of .cb[`input$fill`] changes

``` {r, eval = FALSE}
library(shiny)
library(BristolVis)
library(ggplot2)

ui <- fluidPage(
      selectInput(inputId = "fill",
                         label = "Variable to fill by:",
                         choices = c("health","treatment")),
      plotOutput("barPlot")
)

server <- function(input, output) {
   output$barPlot <- renderPlot({
      ggplot(data = med, aes_string(fill = input$fill)) + #<<
         geom_histogram(aes(x = status), stat = "count") #<<
      }) #<<
}

shinyApp(ui = ui, server = server)

```

---

class: inverse, center, middle

# Getting more from `shiny`: <br> Page layout


---

## Alternatives to .cb[`sidebarLayout()`]

.large[__.cb[`fluidRow()`]__]
```{r,eval=FALSE}
ui <- fluidPage(
 fluidRow(column(width= 4),
          column(width= 2), offset= 3),
 fluidRow(column(width= 12))
 ) 
```

.center[
<img src="figs/fluidrow.png" width = 480>
]

---

## Alternatives to .cb[`sidebarLayout()`]

.large[__.cb[`splitLayout()`]__]
```{r,eval=FALSE}
ui <- fluidPage(
 splitLayout( 
    # object 1,
    # object 2
 )
)  
```
.center[
<img src="figs/splitLayout.png" width = 480>
]

---

## .cb[`tabpanels`]

```{r,eval=FALSE}
ui <- navbarPage(title = "Page",
 tabPanel("tab 1", "contents"),
 tabPanel("tab 2", "contents"),
 tabPanel("tab 3", "contents"))
```

---


class: inverse, center, middle

# Getting more from `shiny`: <br> Making `shiny` sparkle

---

## A .cb[`shiny`] UI is a HTML document

Can use HTML ___tags___ to add static elements (such as text) to your app.

For example, in the user interface:

``` {r, eval=FALSE}
ui <- fluidPage(
  h2("Please complete the options below."), #<<
  p("This information will be used to update the graph"), #<<
  selectInput(inputId = "fill",
              label = "Variable to fill by:",
              choices = c("health","treatment"))
)
```
<br>

.center[
<img src="figs/html.png" height = 150 class="border">
]

---

## Adding HTML ___tags___

.large[
The most common tags have wrapper functions to make them easier to use:
]

``` {r, eval=FALSE}
ui <- fluidPage(         
 h1("Header 1"),              # header (can be h1-h6)
 hr(),                        # horizontal rule
 br(),                        # line break
 p("Text"),                   # paragraph text
 p(strong("bold")),           # bold
 p(em("italic")),             # italics         
 p(code("code")),             # code highlighting         
 a(href="", "link"),          # Hyperlink            
 HTML("<p>Raw html</p>")      # Raw html                
)    
```

.large[
Some tags, e.g. .cb[em()] and .cb[strong()] must be nested within a paragraph tag, .cb[p()]

Similar to the control widgets, all tags are followed by a comma, except for the last element in the user interface container

A full list of tags is available on the .cb[`shiny`] Rstudio [cheatsheet](https://shiny.rstudio.com/images/shiny-cheatsheet.pdf)

]

---

class: inverse, center, middle

# Getting more from `shiny`: <br> Reactive programming

---

# Shiny is reactive . . . 

As discussed, the code contributing to `output$<id>` in the example below 



In fact, Shiny will prevent you from calling reactive expressions outside of these functions.

???



---

## . . . but in a lazy way

`r countdown(minutes = 2, play_sound=TRUE, warn_when = 30, top = 0)`

Compare what happens when we change .cb[`input$fill`] in the following:

``` {r, eval = FALSE}
server <- function(input, output) {

 output$barPlot <- renderPlot({
      `data` <- head(med, n = `input$slider`) 
      ggplot(data = `data`, aes_string(fill = `input$fill`)) +
      geom_histogram(aes(x = status), stat = "count")
  })
}
```

versus:

``` {r, eval = FALSE}
server <- function(input, output) {
  `data` <- reactive({
        head(med, n = `input$slider`) 
  })

 output$barPlot <- renderPlot({
    ggplot(data = `data()`, aes_string(fill = `input$fill`)) +
      geom_histogram(aes(x = status), stat = "count")
  })
}
```

---

## The .cb[`reactive({ })`] function

.large[

The difference: changing the value of .cb[`input$fill`] in the second example does not require the data to be re-calculated:


* `renderPlot` calls `data()`
]

```{r, eval=FALSE}
data <- `reactive({` head(med, n = input$slider) `})`
```

.large[
* `data()` will check that the value of `input$slider` has not changed
* `data()` will return its saved data ___without___ re-subsetting the _med_ dataset
* `renderPlot` will re-draw the histogram with the correct fill.  
]

.center[
<img src="figs/dependencies.png" width = 300>
]

???
Shiny caches the results of .cb[`data()`] and continously validates the value of .cb[`input$slider`] on which it depends. 

You can use this behavior to prevent Shiny from re-running code unnecessarily. 

Important when, for example, loading big datasets from the web -> time consuming if all you want to do is change the title. . . 

---

## Dependencies



---

## .yt[Your Turn: Try a reactive expression]

.Large[

* Open "Example?.R"

* Run the app to see what it does

* Create a reactive expression so that the data does not have to be imported everytime the title is changed

* Re-run your app to ensure that it works as expected

]

---

## .yt[Your Turn: Build an app from scratch]
Open a new Shiny app (File -> New File -> Shiny Web App. . .)

Develop your app
  * Use one of the layouts we discussed as part of this workshop
  
  * Load `shiny`, `BristolVis` and `ggplot2` packages
  
  * Add some text to the app to describe the dataset used
   
  * Add at least one widget to the .cb[`sidebarPanel`]
   
  * Add a plot to the .cb[`mainPanel`] that makes use of the input from your  widget

Run the app to ensure that it works as expected, and compare your app/code with a neighbour

Remember:



`r countdown(minutes = 20, play_sound=TRUE, warn_when = 120)`

---

class: inverse, center, middle

# Getting more from `shiny`: <br> Sharing/publishing your app

---

## .yt[Your Turn: Publish your app]

.Large[
* Ensure that your app.R file is contained within its own folder

* Deploy your app online
  * Go to shinyapps.io
  * Follow the instructions there
  * Send the link to your new app, plus a brief description of what it does, to us here:
  
.center[bit.ly/TBC

Link to Google form
]

]

`r countdown(minutes = 8, play_sound=TRUE, warn_when = 120)`


---

class: inverse, center, middle

# Tips and tricks

---

## Images
Oar: By Florian Pépellin - Own work, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=43042720